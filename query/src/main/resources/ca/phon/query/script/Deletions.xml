<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<query xmlns="http://phon.ling.mun.ca/ns/query" uuid="909ea40d-9bbc-49d3-a35c-512e25295349" name="Deletions.xml" date="2014-10-15T12:24:54.362-02:30">
    <script>
        <source>/*
params =
		{enum, searchTier, &quot;IPA Target&quot;|&quot;IPA Actual&quot;, 0, &quot;&lt;html&gt;&lt;b&gt;Search Tier&lt;/b&gt;&lt;/html&gt;&quot;}
	;
*/

var GroupFilter = require(&quot;lib/GroupFilter&quot;).GroupFilter;
var AlignedGroupFilter = require(&quot;lib/TierFilter&quot;).TierFilter;
var WordFilter = require(&quot;lib/WordFilter&quot;).WordFilter;
var AlignedWordFilter = require(&quot;lib/TierFilter&quot;).TierFilter;
var SyllableFilter = require(&quot;lib/SyllableFilter&quot;).SyllableFilter;
var ParticipantFilter = require(&quot;lib/ParticipantFilter&quot;).ParticipantFilter;
var PatternFilter = require(&quot;lib/PatternFilter&quot;).PatternFilter;
var PatternType = require(&quot;lib/PatternFilter&quot;).PatternType;
var Pcc = require(&quot;lib/Pcc&quot;).Pcc;
var PccOptions = require(&quot;lib/Pcc&quot;).PccOptions;
var StressPatternOptions = require(&quot;lib/StressPattern&quot;).StressPatternOptions;
var CvPatternOptions = require(&quot;lib/CvPattern&quot;).CvPatternOptions;
var ResultType = require(&quot;lib/PhonScriptConstants&quot;).ResultType;
	
/********************************
 * Setup params
 *******************************/

var filters = {
    &quot;primary&quot;: new PatternFilter(&quot;filters.primary&quot;),
    &quot;targetResultFilter&quot;: new PatternFilter(&quot;filters.targetResultFilter&quot;),
    &quot;actualResultFilter&quot;: new PatternFilter(&quot;filters.actualResultFilter&quot;),
    &quot;group&quot;: new GroupFilter(&quot;filters.group&quot;),
    &quot;groupPattern&quot;: new PatternFilter(&quot;filters.groupPattern&quot;),
    &quot;alignedGroup&quot;: new AlignedGroupFilter(&quot;filters.alignedGroup&quot;),
    &quot;word&quot;: new WordFilter(&quot;filters.word&quot;),
    &quot;wordPattern&quot;: new PatternFilter(&quot;filters.wordPattern&quot;),
    &quot;alignedWord&quot;: new AlignedWordFilter(&quot;filters.alignedWord&quot;),
    &quot;syllable&quot;: new SyllableFilter(&quot;filters.syllable&quot;),
    &quot;speaker&quot;: new ParticipantFilter(&quot;filters.speaker&quot;)
};

var metadataOptions = {
    &quot;pcc_aligned&quot;: new PccOptions(&quot;metadataOptions.pcc_aligned&quot;, true),
    &quot;pcc_standard&quot;: new PccOptions(&quot;metadataOptions.pcc_standard&quot;, false),
    &quot;stressPattern&quot;: new StressPatternOptions(&quot;metadataOptions.stressPattern&quot;),
    &quot;cvPattern&quot;: new CvPatternOptions(&quot;metadataOptions.cvPattern&quot;)
};

var includeAlignedParamInfo = {
    &quot;id&quot;: &quot;includeAligned&quot;,
    &quot;title&quot;: &quot;&quot;,
    &quot;desc&quot;: &quot;Include aligned phones&quot;,
    &quot;def&quot;: true
};
var includeAlignedParam;
var includeAligned = includeAlignedParamInfo.def;

function setup_params(params) {

	filters.primary.setSelectedPatternType(PatternType.PHONEX);
	filters.primary.param_setup(params);
	filters.primary.set_required(true);
	
	// setup result filter section
	var resultFilterSection = new SeparatorScriptParam(&quot;Aligned Phones&quot;, true);
	var targetLbl = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;IPA Target Matcher&lt;/b&gt;&lt;/html&gt;&quot;);
	var actualLbl = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;IPA Actual Matcher&lt;/b&gt;&lt;/html&gt;&quot;);
	
	includeAlignedParam = new BooleanScriptParam(
	    includeAlignedParamInfo.id,
	    includeAlignedParamInfo.desc,
	    includeAlignedParamInfo.title,
	    includeAlignedParamInfo.def);
    
	params.add(resultFilterSection);
	params.add(includeAlignedParam);
	params.add(targetLbl);
	filters.targetResultFilter.setSelectedPatternType(PatternType.PHONEX);
	filters.targetResultFilter.param_setup(params);
	params.add(actualLbl);
	filters.actualResultFilter.setSelectedPatternType(PatternType.PHONEX);
	filters.actualResultFilter.param_setup(params);
	
	var includeAlignedListener = new java.beans.PropertyChangeListener() {
	    propertyChange: function(e) {
	        var enabled = e.source.getValue(e.source.paramId);
	        filters.targetResultFilter.setEnabled(enabled);
	        filters.actualResultFilter.setEnabled(enabled);
	    }  
	};
	includeAlignedParam.addPropertyChangeListener(includeAlignedParamInfo.id, includeAlignedListener);
	var alignedEnabled = includeAlignedParamInfo.def;
    filters.targetResultFilter.setEnabled(alignedEnabled);
	filters.actualResultFilter.setEnabled(alignedEnabled);
	
	filters.group.param_setup(params);
	filters.groupPattern.param_setup(params);
	var sep = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;Aligned Group&lt;/b&gt;&lt;/html&gt;&quot;);
	params.add(sep);
	filters.alignedGroup.param_setup(params);
	
	filters.word.param_setup(params);
	filters.wordPattern.param_setup(params);
    filters.wordPattern.setEnabled(false);
	var wordsep = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;Aligned Word&lt;/b&gt;&lt;/html&gt;&quot;);
    params.add(wordsep);
    filters.alignedWord.param_setup(params);
    var searchByWordListener = new java.beans.PropertyChangeListener {
        propertyChange: function(e) {
            var enabled = e.source.getValue(e.source.paramId);
            filters.wordPattern.setEnabled(enabled);
            filters.alignedWord.setEnabled(enabled);
        }    
    };
    filters.word.searchByWordOpt.addPropertyChangeListener(filters.word.searchByWordOpt.paramId, searchByWordListener);
    var enabled = filters.word.searchByWordOpt.getValue(filters.word.searchByWordOpt.paramId);
    filters.wordPattern.setEnabled(enabled);
    filters.alignedWord.setEnabled(enabled);
    
	filters.syllable.param_setup(params);
	filters.speaker.param_setup(params);
	
	// add metadata options
	var metadataSep = new SeparatorScriptParam(&quot;Metadata Options&quot;, true);
	params.add(metadataSep);
	
	var spLbl = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;Stress Pattern&lt;/b&gt;&lt;/html&gt;&quot;);
	params.add(spLbl);
	metadataOptions.stressPattern.param_setup(params);
	
	var cvLbl = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;CGV Pattern&lt;/b&gt;&lt;/html&gt;&quot;);
	params.add(cvLbl);
	metadataOptions.cvPattern.param_setup(params);

    var pccStandardLbl = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;PCC/PVC (standard)&lt;/b&gt;&lt;/html&gt;&quot;);
    params.add(pccStandardLbl);
    metadataOptions.pcc_standard.param_setup(params);

	var pccAlignedLbl = new LabelScriptParam(&quot;&quot;, &quot;&lt;html&gt;&lt;b&gt;PCC/PVC (aligned)&lt;/b&gt;&lt;/html&gt;&quot;);
	params.add(pccAlignedLbl);
	metadataOptions.pcc_aligned.param_setup(params);
}

/*
 * Globals
 */
var session;

function begin_search(s) {
    session = s;
}


/********************************
 * query_record
 * params:
 * 	record - the current record
 *******************************/
function query_record(recordIndex, record) {
    // check participant filter
    if(!filters.speaker.check_speaker(record.speaker)) return;
    
    // check group+groupPattern filters
	var groups = filters.group.getRequestedGroups(record);
    if(filters.groupPattern.isUseFilter()) {
        groups = filters.groupPattern.filter_groups(groups, searchTier);
    }
	
	// check aligned group for each group returned
	if(filters.alignedGroup.isUseFilter()) {
	    groups = filters.alignedGroup.filter_groups(record, groups);
	}

	// perform searches
	for(var i = 0; i &lt; groups.length; i++)
	{
		var group = groups[i];
		var ipa = (searchTier == &quot;IPA Target&quot; ? group.IPATarget : group.IPAActual);
		
		var toSearch = new Array();
		toSearch.push(ipa);
		
		// search by word?
		if(filters.word.isUseFilter()) {
		   toSearch.length = 0;
		   var selectedWords = filters.word.getRequestedWords(group);
		   for(j = 0; j &lt; selectedWords.length; j++) {
		       var word = selectedWords[j];
		       var addWord = true;

               var wordIpa = (searchTier == &quot;IPA Target&quot; ? word.IPATarget : word.IPAActual);
               // check word pattern if necessary
		       if(filters.wordPattern.isUseFilter()) {
		           addWord = filters.wordPattern.check_filter(wordIpa);
		       }
		      
		       // check aligned word pattern if necessary
		       if(filters.alignedWord.isUseFilter()) {
		           addWord = filters.alignedWord.check_word(word);
		       }
		       
		       if(addWord) {
		           toSearch.push(wordIpa);
		       }
		   }
		}
		
		// search by syllable?
		if(filters.syllable.isUseFilter()) {
		    var syllList = new Array();
		    for(j = 0; j &lt; toSearch.length; j++) {
		        var obj = toSearch[j];
		        var sylls = filters.syllable.getRequestedSyllables(obj);
		        
		        for(k = 0; k &lt; sylls.length; k++) {
		            syllList.push(sylls[k]);
		        }
		    }
		    toSearch = syllList;
		}
		
		for(j = 0; j &lt; toSearch.length; j++) {
		    var obj = toSearch[j];
		    var matches = filters.primary.find_pattern(obj);
		    var primaryFilter = (searchTier == &quot;IPA Target&quot; ? filters.targetResultFilter : filters.actualResultFilter);
		    var alignedFilter = (searchTier == &quot;IPA Target&quot; ? filters.actualResultFilter : filters.targetResultFilter);
		    
		    for(k = 0; k &lt; matches.length; k++) {
    	        var match = matches[k];
    	        
    	        if(primaryFilter.isUseFilter()) {
    	        	if(!primaryFilter.check_filter(new IPATranscript(match.value))) {
    	        		continue;
    	        	}
    	        }
    	        
    			var result = factory.createResult();
    			// calculate start/end positions of data in text
    			var startIndex = ipa.stringIndexOf(match.value);
    			var length = match.value.toString().length();
    			
    			result.recordIndex = recordIndex;
    			result.schema = &quot;LINEAR&quot;;
    
    			var rv = factory.createResultValue();
    			rv.tierName = searchTier;
    			rv.groupIndex = group.groupIndex;
    			rv.range = new Range(startIndex, startIndex + length, false);
    			rv.data = (match.value != null ? new IPATranscript(match.value) : new IPATranscript());
    			result.addResultValue(rv);
    			
    			if(includeAligned) {
    			    var phoneMap = group.phoneAlignment;
    			    var alignedGroup = (searchTier == &quot;IPA Target&quot; ? group.getIPAActual() : group.getIPATarget());
    			    var aligned = phoneMap.getAligned(match.value);
    			    var alignedIpaElements = (aligned != null ? new IPATranscript(aligned) : new IPATranscript());
    			    
    			    // find location of aligned value in group
    			    var groupStartIdx = 
    			    (alignedIpaElements.length() > 0 ? alignedGroup.indexOf(alignedIpaElements.elementAt(0)) : 0);
    			    var groupEndIdx = 
    			    (alignedIpaElements.length() > 0 ? alignedGroup.indexOf(alignedIpaElements.elementAt(alignedIpaElements.length()-1)) : 0);
    			    var alignedIpa = alignedGroup.subsection(groupStartIdx, groupEndIdx+1);
    			    
    			    var alignedRv = factory.createResultValue();
    			    alignedRv.tierName = (searchTier == &quot;IPA Target&quot; ? &quot;IPA Actual&quot; : &quot;IPA Target&quot;);
    			    alignedRv.groupIndex = group.groupIndex;
    			   	if(aligned != null &amp;&amp; aligned.length &gt; 0) {
    			   		var alignedStart = alignedGroup.stringIndexOf(alignedIpa);
    			   		var alignedLength = alignedIpa.toString().length();
    			   		
    			   		alignedRv.range = new Range(alignedStart, alignedStart + alignedLength, false);
    			    	alignedRv.data = alignedIpa;
    			   	} else {
    			   		alignedRv.range = new Range(0, 0, true);
    			   		alignedRv.data = &quot;&quot;;
    			   	}
    			    
    			    result.addResultValue(alignedRv);
    			    result.schema = &quot;ALIGNED&quot;;
    			    calcMetadata(record, group, result.metadata, 
    			    		(match.value == null ? null : new IPATranscript(match.value)), 
    			    		(aligned == null ? null : new IPATranscript(aligned)) );
    			} else {
    				calcMetadata(record, group, result.metadata, 
    						(match.value == null ? null : new IPATranscript(match.value)), null);
    			}
    			
    			results.addResult(result);
    	    }
		}
	}
}

/********************************
 * Functions
 *******************************/

/* Generate metadata based on parmeters */
function calcMetadata(record, group, metadata, ipaTVal, ipaAVal) {
    var retVal = metadata;
    
    if(metadataOptions.stressPattern.include == true) {
        var tsp = (ipaTVal == null ? null : ipaTVal.stressPattern);
        var asp = (ipaAVal == null ? null : ipaAVal.stressPattern)
        
        if(tsp != null &amp;&amp; asp != null &amp;&amp; metadataOptions.stressPattern.separate == false) {
            var sp = tsp + &quot; \u2194 &quot; + asp;
            retVal.put(&quot;SP&quot;, sp);
        } else {
            if(tsp != null) {
                var name = (metadataOptions.stressPattern.separate == true ? &quot;SP-T&quot; : &quot;SP&quot;);
                retVal.put(name, tsp);
            }
            if(asp != null) {
                var name = (metadataOptions.stressPattern.separate == true ? &quot;SP-A&quot; : &quot;SP&quot;);
                retVal.put(name, asp);
            }
        }
    }
    
    if(metadataOptions.cvPattern.include == true) {
        var tcv = (ipaTVal == null ? null : ipaTVal.cvPattern);
        var acv = (ipaAVal == null ? null : ipaAVal.cvPattern);
        
        if(tcv != null &amp;&amp; acv != null &amp;&amp; metadataOptions.cvPattern.separate == false) {
            var cv = tcv + &quot; \u2194 &quot; + acv;
            retVal.put(&quot;CGV&quot;, cv);
        } else {
            if(tcv != null) {
                var name = (metadataOptions.cvPattern.separate == true ? &quot;CGV-T&quot; : &quot;SP&quot;);
                retVal.put(name, tcv);
            }
            if(acv != null) {
                var name = (metadataOptions.cvPattern.separate == true ? &quot;CGV-A&quot; : &quot;SP&quot;);
                retVal.put(name, acv);
            }
        }
    }
    
    if(group != null) {
        metadataOptions.pcc_standard.setup_pcc_standard_metadata(group, retVal);
        metadataOptions.pcc_aligned.setup_pcc_aligned_metadata(group, retVal);
    }
}
</source>
        <param id="filters.actualResultFilter.caseSensitive">false</param>
        <param id="filters.actualResultFilter.exactMatch">true</param>
        <param id="filters.actualResultFilter.filter">^$</param>
        <param id="filters.actualResultFilter.filterType">Phonex</param>
        <param id="filters.alignedGroup.patternFilter.filterType">Plain text</param>
        <param id="filters.alignedWord.patternFilter.filterType">Plain text</param>
        <param id="filters.groupPattern.filterType">Plain text</param>
        <param id="filters.primary.filter">[\c\v]</param>
        <param id="filters.primary.filterType">Phonex</param>
        <param id="filters.speaker.age1Comparator">equal to</param>
        <param id="filters.speaker.age2Comparator">equal to</param>
        <param id="filters.speaker.ageOperator">(select operator)</param>
        <param id="filters.speaker.participantRole">(select role)</param>
        <param id="filters.targetResultFilter.filterType">Phonex</param>
        <param id="filters.wordPattern.filterType">Plain text</param>
        <param id="searchTier">IPA Target</param>
    </script>
</query>
